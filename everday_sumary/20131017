专业课
专业课今天把树的题目做了，并且今天超过一半的时间都花在这里。
各种树的考点很多，其中线索树个人觉得比较难。
性质多考完全二叉树
总结
1.完全二叉树的性质总结
1.节点个数最多 2^h-1
2.只有度为0和2的点，最多可能有一个度为1的点（和2 叉huffman tree一样。满二叉树则只有度为0和2
3.父母节点关系
4.根据编号得出高度

BST
注意最小或最大的元素是最左边的叶子节点、最右的叶子节点是错误的（不要求一定是叶子，只要满足最左或最右即可）

线索二叉数
1.注意总结三种线索二叉树获取第一个元素，获取前一个元素，获取下一个元素，的方法
2.构造线索二叉树采用了“带出pre的递归方法”，在真正访问到一个节点是会更新pre，上一次递归调用的函数可以利用pre的信息去更新节点信息。
注意在最后要把最后一个节点的后继指针置零。

一般树转二叉树
二叉树转森林
森林转二叉树

huffmantree
编码数量N，则节点数量2N-1（创建了N-1个额外节点）

遍历
1.先序序列和后续序列不能确定唯一树


总结下今天做过的树相关算法题
1.非递归法求树的高度
    非递归一般要用队列或栈
    用广度遍历（层次遍历）
    关键在要有办法标识队列中某元素为改层最后一个元素然后更新高度++
    答案用的方法空间复杂度太高。。
    我用了一个level-count和heigh变量
    next-level-count一般为下一层的节点个数，在enqueue时更新
    this-level-count本层节点个数，初始化为1
    没访问一个节点 this-level-count--,为零时heigh++，并变为next-level-count，next-level-count置零。
    循环访问直至队列为空

2.求制定元素层次
    easy
3.求共同祖先，两个位置“交替”计算祖先直到重合。
4.确认是完全二叉树
    我用的方法是确认每个点的性质，总结起来较麻烦。
    答案用的是一个很simple的原则“无左子就不应有右字”
    利用了完全二叉树节点编号”连续“特性，不断将节点enqueue
    若发现有断号则后续必须为空，若队列后续有出现了非空节点则说明不连续，（dequeue节点为空）
    整个队列最终没有节点了则返回一。

5.证明是bst
    我的思路是递归求解，并且要确保坐子树最大元素少于本节点，右子树最小元素大于本节点
    答案用了“若为二叉树，则中续遍历为有序数列”！！！
    并且算法非常短小。。

6.构造叶子节点的链表
    我用的是dfs构造
    答案用的是中续遍历构造。
    注意最后一个点不要忘记处理。

7.完全二叉树前序改后序列
    注意完全二叉树的结构良好性使只要一种遍历即可完全确定二叉树
    数组的不断递归分块调节。

8.计算度为1的点
    递归，注意递归函数返回值就是个数（这个比较优美。。）

    int num(BTree T)
    {
        if(isleafnode(T))
        {
            return 0;
        }
        if(T->left && T->right)
        {
            return num(T->left) + num(T->right);
        }
        else
        {
            if(T->left)
            {
                return num(T->left)+1;
            }
            else
            {
                return num(T->right)+1;
            }
        }
    }

数学只证明了不定积分（换元第一定理和第二定理、分部积分、有理式积分）

英语看到了parallel structure，觉得这个排比还是很有用的）


政治看到了社会发展规律了吧。。要开始做题了。
